import cmd
import rsa
import os
import json
import blockchain
import AuthorizationKeyMethods
import DBAdapter
import Network



def getPrivateKeyFromFile(fname):
    try:
        fname = os.path.abspath(fname)                                                                                  #Переход по пути к файлу с ключем
        f = open(fname, 'r')                                                                                            #Открытие файла с ключем с атриботом "Только для чтения"
        l = f.readlines()                                                                                               #Считывание содержимого файла по строкам
        n = int(l[0][:-1])                                                                                              #Считывание строк без последнего символа(им обычно указан пробел)
        e = int(l[1][:-1])
        d = int(l[2][:-1])
        p = int(l[3][:-1])
        q = int(l[4][:-1])
        PrivateKey = rsa.PrivateKey(n, e, d, p, q)                                                                      #Считывание закрытого ключа по алгоритму RSA
        return PrivateKey
    except Exception as e:
        print('Not valid key or wrong unknown file, try again')
        return False

class Cli(cmd.Cmd):

    Network = None
    DBAdapter = None
    AuthorizationKeyMethods = None
    isAuthorized = False

    def __init__(self):
        cmd.Cmd.__init__(self, '\f')
        self.DBA = DBAdapter.DBAdapter()
        self.AuthKeyMeth = AuthorizationKeyMethods.AuthorizationKeyMethods()
        self.Cblockchain = blockchain.Blockchain()
        self.CNetwork = Network.Network(blockchain)

        self.intro = 'Welcome to system. Please, Authorization.'
        self.prompt = 'Not auth==>'
        self.doc_header = 'Введите help для более подробной информации'

    def default(self, line):
        '''
        При вводе несуществующей команды, выдаёт ошибку
        :param line:
        :return:
        '''
        print('Неверная команда. Введите help для более подробной информации. \n')                                      #Вывод ошибки при вводе несуществующей команды

    def do_login(self, args):
        '''
        Команда для авторизации пользователя в сети
        :param args:
        :return:
        '''
        var = True
        while(var == True):
            pathPrivateKey = input('Please, enter way to private key:\n')                                               #Указание пути для файла с закрытым ключем
            PrivateKey = self.getPrivateKeyFromFile(pathPrivateKey)                                                     #Присвоение закрытого ключа переменной
            if (PrivateKey):
                if (self.AuthKeyMeth.authorization(PrivateKey)):
                    self.intro = 'Welcome to system. Type help to list commands.\n'
                    self.prompt = '====>'
                    self.doc_header = 'Введите help для более подробной информации'
                    self.isAuthorized = True
                    PublicKey = str(self.AuthKeyMeth.PrivateKeyToPublic(PrivateKey))
                    name = self.DBA.GetUserByPublicKey(PublicKey)['FIO']
                    return print('Hello', name)
                else:
                    print('InvalidKey, try again')
            else:
                exit(0)

    def do_logout(self, args):
        '''
        Команда для выхода из сети
        :param args:
        :return:
        '''
        self.prompt = 'Not auth==>'
        self.doc_header = 'You out of network'
        self.isAuthorized = False

    def GeneratePrivateKey(self):
        '''
        Генерирование закрытого ключа
        :return:
        '''
        PrivateKey = self.AuthKeyMeth.generateKey()
        s = 0
        stat = True
        while stat:
            if not os.path.exists('keys\PrivateKey_' + str(s)):
                f = open('keys\PrivateKey_' + str(s), 'w')
                print()
            else:
                s = s + 1
            f.write(str(PrivateKey.n + '\n'))
            f.write(str(PrivateKey.e + '\n'))
            f.write(str(PrivateKey.d + '\n'))
            f.write(str(PrivateKey.p + '\n'))
            f.write(str(PrivateKey.q + '\n'))
            print(self, 'Attention, key was generated, save him')
            AbsolutePathToFile = os.path.abspath('keys\PrivateKey_' + str(s))
            return AbsolutePathToFile

    def do_CreateUser(self, argv):
        '''
        Команда для создания нового пользователя (только для ЦУУ)
        :param argv:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            if (self.AuthKeyMeth.account['Role'] == "Admin"):                                                           #Проверка допустимых прав для пользователя
                Transact = {}
                datadict = {}
                Type = input('Enter type user: \n open\closed \n')                                                      #Выбор типа голосования (открытое, закрытое)
                if (Type == 'open') or (Type == 1) or (Type == 'Open'):                                                 #Проверка выбора пользователя, в данном случае для открытого голосования
                    datadict['FIO'] = input('Please enter full name: \n ')                                              #Ввод ФИО для заполнения словаря

                    print (' 1) Student \n 2) Aspirant \n 3) PPSinUSU \n 4) PPSnotInUSU \n 5) Auditors \n')
                    Num = ['Student', 'Aspirant', 'PPSinUSU', 'PPSnotInUSU', 'Auditors']                                #Задание массива с ролями для выбора
                    datadict['Role'] = input('Select role:\n')                                                          #Выбор роли для пользоватей

                    Num2 = [1, 0]                                                                                       #Задание массива для участия пользователя в ИК
                    C = input('You consists at IK? \n Y/N \n')
                    if (C == 'Y') or (C == 'y') or (C == 'да') or (C == 'Да') or (C == 'ДА'):                           #Проверка выбора пользователя
                        datadict['isIK'] = Num2[0]
                    else:
                        datadict['isIK'] = Num2[1]

                    Transact['data'] = datadict                                                                         #Сбор данных в транзакцию
                    Transact['Type'] = 0                                                                                #Задание типа для транзакции (Регистрация в открытые пользователи)
                    path = self.GeneratePrivateKey()
                    PrivateKey = self.getPrivateKeyFromFile(path)
                    Transact['publicKey'] = self.AuthKeyMeth.PublicKeyToString(PrivateKey)
                    string = json.dumps(Transact, sort_keys=True)
                    signature = self.AuthKeyMeth.CreateSignature(string, PrivateKey)
                    Transact['signature'] = signature
                if (Type == 'closed') or (Type == 2):                                                                   #Проверка голосования, в данном случае для закрытого голосования
                    datadict['FIO'] = input('Please enter full name: \n ')                                              #Ввод ФИО для заполнения словаря

                    print(' 1) Student \n 2) Aspirant \n 3) PPSUSU \n 4) PPSnotInUSU \n 5) Auditors \n 6) Admin')
                    Num = ['Student', 'Aspirant', 'PPSUSU', 'PPSnotUSU', 'Auditors', 'Admin']                           #Задание массива с ролями для выбора
                    datadict['Role'] = input('Select role:\n',)                                                         #Выбор роли для пользователя

                    Num2 = [1, 0]                                                                                       #Задание массива для участия пользователя в ИК
                    C = print ('You consists at IK? \n Y/N \n')
                    if (C == 'Y') or (C == 'y') or (C == 'да') or (C == 'Да') or (C == 'ДА'):                           #Проверка выбора пользователя
                        datadict['isIK'] = Num2[0]
                    else:
                        datadict['isIK'] = Num2[1]
                    path = self.GeneratePrivateKey()
                    PrivateKey = self.getPrivateKeyFromFile(path)
                    Transact['data'] = datadict                                                                         #Сбор данных в транзакцию
                    Transact['Type'] = 1                                                                                #Задание типа для транзакции (Регистрация в закрытые пользователи)
                    Transact['publicKey'] = self.AuthKeyMeth.PublicKeyToString(PrivateKey)
                    string = json.dumps(Transact, sort_keys=True)
                    signature = self.AuthKeyMeth.CreateSignature(string, PrivateKey)
                    Transact['signature'] = signature
            else:
                print('Insufficiently rights access')                                                                   #Оповещение об ошибке при недостатке прав доступа
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя

    def getPrivateKeyFromFile(self, fname):
        try:
            fname = os.path.abspath(fname)                                                                              #Переход по пути к файлу с ключем
            f = open(fname, 'r')                                                                                        #Открытие файла с ключем с атриботом "Только для чтения"
            l = f.readlines()                                                                                           #Считывание содержимого файла по строкам
            n = int(l[0][:-1])                                                                                          #Считывание строк без последнего символа(им обычно указан пробел)
            e = int(l[1][:-1])
            d = int(l[2][:-1])
            p = int(l[3][:-1])
            q = int(l[4][:-1])
            PrivateKey = rsa.PrivateKey(n, e, d, p, q)                                                                  #Считывание закрытого ключа по алгоритму RSA
            return PrivateKey
        except Exception as e:
            print('Invalid Key, try again')
            return False

    def do_CreateOpenVoting(self, args):
        '''
        Команда для создания открытого голосования (только для ИК)
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            if (self.AuthKeyMeth.account['IsIk'] == "1"):                                                               #Проверка состава в ИК
                Transact = {}
                datadict = {}
                datadict['Vote'] = input('Please, enter question voting: \n')                                           #Создание вопроса голосования
                Num3 = input('Please, enter time of voting: \n')                                                        #Указание количества дней для голосования
                if (Num3 == 1) or (Num3 == 2) or (Num3 == 3) or (Num3 == 4):                                            #Заданный диапазон от 1 до 4 дней
                    datadict['time'] = Num3
                else:
                    print('Incorrect time \n')
                datadict['Role'] = input('Please, enter role, who can vote: \n')                                        #Написание ролей, которым можно голосовать
                Transact['data'] = datadict                                                                             #Сбор данных в транзакцию
                Transact['Type'] = 2                                                                                    #Задача типа транзакции (Создание открытого голосования)
                PrivateKey = self.AuthKeyMeth.account['PrivateKey']
                Transact['publicKey'] = self.AuthKeyMeth.account['PublicKey']
                string = json.dumps(Transact, sort_keys=True)
                signature = self.AuthKeyMeth.CreateSignature(string, PrivateKey)
                Transact['signature'] = signature                                                                       #Отправка подписи
            else:
                print('Insufficiently rights access')
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя

    def do_CreateCloseVoting(self, args):
        '''
        Команда для создания закрытого голосования (только для ИК)
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            if (self.AuthKeyMeth.account['IsIk'] == "1"):                                                               #Проверка состава в ИК
                Transact = {}
                datadict = {}
                datadict['Content'] = input('Please, enter question voting: \n')                                        #Создание вопроса голосования
                Num4 = input('Please, enter time of voting: \n')                                                        #Указание количества дней для голосования
                if (Num4 == 1) or (Num4 == 2) or (Num4 == 3) or (Num4 == 4):                                            #Заданный диапазон от 1 до 4 дней
                    datadict['time'] = Num4
                else:
                    print('Incorrect time \n')
                datadict['Role'] = input('Please, enter role, who can vote: \n')                                        #Написание ролей, которым можно голосовать
                Transact['data'] = datadict                                                                             #Сбор данных в транзакцию
                Transact['Type'] = 3                                                                                    #Задача типа транзакции (Создание закрытого голосования)
                PrivateKey = self.AuthKeyMeth.account['PrivateKey']
                Transact['publicKey'] = self.AuthKeyMeth.account['PublicKey']
                string = json.dumps(Transact, sort_keys=True)
                signature = self.AuthKeyMeth.CreateSignature(string, PrivateKey)
                Transact['signature'] = signature                                                                       #Отправка подписи
            else:
                print('Insufficiently rights access')
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя

    def do_UpRole(self, args):
        '''
        Команда для повышения роли (только для ЦУУ)
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            if (self.AuthKeyMeth.account['Role'] == "Admin"):                                                           #Проверка допустимых прав для пользователя

                Transact = {}
                datadict = {}
                Transact['data'] = datadict                                                                             #Сбор данных в транзакцию
                Transact['Type'] = 5                                                                                    #Задача типа транзакции (Повышение роли)
                PrivateKey = self.AuthKeyMeth.account['PrivateKey']
                Transact['publicKey'] = self.AuthKeyMeth.account['PublicKey']
                string = json.dumps(Transact, sort_keys=True)
                signature = self.AuthKeyMeth.CreateSignature(string, PrivateKey)
                Transact['signature'] = signature                                                                       #Отправка подписи

            else:
                print('Insufficiently rights access')                                                                   #Оповещение об ошибке при недостатке прав доступа
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя

    def do_DownRole(self, args):
        '''
        Команда для понижения роли (только для ЦУУ)
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            if (self.AuthKeyMeth.account['Role'] == "Admin"):                                                           #Проверка допустимых прав для пользователя
                Transact = {}
                datadict = {}
                Transact['data'] = datadict                                                                             #Сбор данных в транзакцию
                Transact['Type'] = 6                                                                                    #Задача типа транзакции (Понижение роли)
                PrivateKey = self.AuthKeyMeth.account['PrivateKey']
                Transact['publicKey'] = self.AuthKeyMeth.account['PublicKey']
                string = json.dumps(Transact, sort_keys=True)
                signature = self.AuthKeyMeth.CreateSignature(string, PrivateKey)
                Transact['signature'] = signature                                                                       #Отправка подписи
            else:
                print('Insufficiently rights access')                                                                   #Оповещение об ошибке при недостатке прав доступа
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя

    def do_InquiryVoting(self, args):
        '''
        Подать запрос для голосования
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            if (self.AuthKeyMeth.account['Role'] == "Student") \
                    or (self.AuthKeyMeth.account['Role'] == "Aspirant"):                                                #Проверка допустимых прав для пользователя
                Transact = {}
                datadict = {}
                datadict['voting'] = input('Choice type voting: \n open\closed')                                        #Выбор типа голосования
                datadict['vote'] = input('Please, specify inquiry:\n 1) Become member IK \n 2) Withdraw member IK')     #Выбор вида голосования
                if (datadict['vote'] == 1):                                                                             #Выбор голосования для становления членом ИК
                    datadict['FIO'] = input('Enter your name from inquiry: \n')                                         #Ввод имени для отправки транзакции
                    Transact['data'] = datadict                                                                         #Сбор данных в транзакцию
                    Transact['Type'] = 7                                                                                #Задача типа транзакции (добавление в ИК)

                if (datadict['vote'] == 2):                                                                             #Выбор голосования для исключения из ИК
                    datadict['FIO'] = input('Enter FIO member, whom you want to withdraw: \n')                          #Ввод имени для отправки транзакции
                    Transact['data'] = datadict                                                                         #Сбор данных в транзакцию
                    Transact['Type'] = 8                                                                                #Задача типа транзакции (отстранить от ИК)
                PrivateKey = self.AuthorizationKeyMethods.account.get['PrivateKey']
                Transact['publicKey'] = self.AuthorizationKeyMethods.account.get['PublicKey']
                string = json.dumps(Transact, sort_keys=True)
                signature = AuthorizationKeyMethods.AuthorizationKeyMethods.CreateSignature(string, PrivateKey)
                Transact['signature'] = signature                                                                       #Отправка подписи

            if (self.AuthKeyMeth.account['Role'] == "PPSUSU") \
                    or (self.AuthKeyMeth.account['Role'] == "PPSnotUSU"):                                               #Проверка допустимых прав для пользователя
                Transact = {}
                datadict = {}
                datadict['voting'] = input('Choice type voting: \n open\closed')                                        #Выбор типа голосования
                datadict['vote'] = input('Please, specify inquiry:\n 1) Become member IK \n 2) Withdraw member IK')     #Выбор вида голосования
                if (datadict['vote'] == 1):                                                                             #Выбор голосования для становления членом ИК
                    datadict['FIO'] = input('Enter your name from inquiry: \n')                                         #Ввод имени для отправки транзакции
                    Transact['data'] = datadict                                                                         #Сбор данных в транзакцию
                    Transact['Type'] = 7                                                                                #Задача типа транзакции (добавление в ИК)

                if (datadict['vote'] == 2):                                                                             #Выбор голосования для исключения из ИК
                    datadict['FIO'] = input('Enter FIO member, whom you want to withdraw: \n')                          #Ввод имени для отправки транзакции
                    Transact['data'] = datadict                                                                         #Сбор данных в транзакцию
                    Transact['Type'] = 8                                                                                #Задача типа транзакции (отстранить от ИК)
                PrivateKey = self.AuthKeyMeth.account['PrivateKey']
                Transact['publicKey'] = self.AuthKeyMeth.account['PublicKey']
                string = json.dumps(Transact, sort_keys=True)
                signature = self.AuthKeyMeth.CreateSignature(string, PrivateKey)
                Transact['signature'] = signature                                                                       #Отправка подписи
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя

    def do_vote(self, args):
        '''
        Команда для голосования
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            Transact = {}
            datadict = {}

            datadict['voting'] = input('Please choice voting:\n')

            datadict['vote'] = input('Please vote:\n')

            Transact['data'] = datadict                                                                                 #Сбор данных в транзакцию
            Transact['Type'] = 4                                                                                        #Задача типа транзакции (проголосовать)
            PrivateKey = self.AuthKeyMeth.account['PrivateKey']
            Transact['publicKey'] = self.AuthKeyMeth.account['PublicKey']
            string = json.dumps(Transact, sort_keys=True)
            signature = self.AuthKeyMeth.CreateSignature(string, PrivateKey)
            Transact['signature'] = signature                                                                           #Отправка подписи
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя

    def do_help(self, args):
        '''
        Команда для вызова помощи
        :param args:
        :return:
        '''
        print('login - Команда для авторизации пользователя в сети \nlogout - Команда для выхода из сети\n'             #Вывод информации по всем имеющимся командам
              'CreateUser - Команда для создания нового пользователя (только ЦУУ)\n'
              'CreateOpenVoting - Команда для создания открытого голосования (только ИК)\n'
              'CreateCloseVoting - Команда для создания закрытого голосования (только ИК)\n'
              'UpRole - Команда для повышения роли (только ЦУУ) \nDownRole - Команда для понижения роли (только ЦУУ)\n'
              'vote - Команда для голосования\n'
              'ChangeInIKUser - Команда для изменения положения пользователя в избирательной комиссии\n'
              'DeleteUser - Команда для удаления пользователя (только ЦУУ)\n'
              'InquiryResultsVoting - Команда для запроса результатов по всем прошедшим голосованиям\n'
              'InquiryAvailableVoting - Команда для запроса доступных голосований\n'
              'CountVote - Команда для подсчета голосов (только ИК и аудиторы)\n'
              'InquiryVoting - Команда для подачи запроса на голосования\n'
              'InspectionVotes - Команда для проверки голосов (только ИК и аудиторы)\n'
              'EditingProfile - Команда для редактирования профиля\n'
              'TaxInquiryRecoveryKeys - Команда подачи запроса для восстановления ключей доступа к системе\n'
              'RecoveryKeys - Команда для восстановления ключей для доступа к системе (только ЦУУ)\n'
              'FindUser - Команда для поиска пользователя в цепочке блоков(для проверки анонимности)(только аудиторы)\n'
              'AppointAuditor - Команда для назначения случайного аудитора (только ЦУУ)\n'
              'AppointUserIK - Команда для назначения случайного члена избирательной комиссии (только ЦУУ)\n'
              'exit - Команда для выхода из системы')

    def do_ChangeInIKUser(self, args):
        '''
        Команда для изменения положения пользователя
        в избирательной комиссии (только для ЦУУ)
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            if (self.AuthKeyMeth.account['Role'] == "Admin"):                                                           #Проверка допустимых прав для пользователя
                Transact = {}
                datadict = {}
                Transact['data'] = datadict                                                                             #Сбор данных в транзакцию
                Transact['Type'] = 7                                                                                    #Задача типа транзакции
                PrivateKey = self.AuthKeyMeth.account['PrivateKey']
                Transact['publicKey'] = self.AuthKeyMeth.account['PublicKey']
                string = json.dumps(Transact, sort_keys=True)
                signature = self.AuthKeyMeth.CreateSignature(string, PrivateKey)
                Transact['signature'] = signature                                                                       #Отправка подписи
            else:
                print('Insufficiently rights access')                                                                   #Оповещение об ошибке при недостатке прав доступа
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя

    def do_DeleteUser(self, args):
        '''
        Команда для удаления пользователя (только ЦУУ)
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            if (self.AuthKeyMeth.account['Role'] == "Admin"):                                                           #Проверка допустимых прав для пользователя
                PublicKey = self.AuthKeyMeth.PublicKeyToString()                                                        #Запрос данных необходимых для удаления пользователя
                info = self.DBA.DeleteUser(PublicKey)                                                                   #Запрос функции сдаления пользователя с БД
                exec(info)                                                                                              #Исполнение функции
            else:
                print('Insufficiently rights access')                                                                   #Оповещение об ошибке при недостатке прав доступа
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя

    def do_InquiryResultsVoting(self, args):
        '''
        Команда для запроса результатов по всем прошедшим голосованиям
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            result = self.DBA.GetPublicVotesList()                                                                      #Запрос данных по прошедшим голосованиям
            print(result)                                                                                               #Вывод результатов
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя


    def do_InquiryAvailableVoting(self, args):
        '''
        Команда для запроса доступных голосований
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            print()

        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя

    def do_CountVote(self, args):
        '''
        Команда для подсчета голосов (только ИК и аудиторы)
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            if (self.AuthKeyMeth.account['Role'] == "Auditor") or \
                    (self.AuthKeyMeth.account['ikIK'] == "1"):                                                          #Проверка допустимых прав для пользователя
                d = input('Choice what vote: \n open\closed')                                                           #Выбор данных какого голосования запрашивать
                if (d == 'open') or (d == 'Open'):                                                                      #Обработка выбора пользователя для открытого голосования
                    a = self.DBA.GetPublicVotesList()                                                                   #Запрос данных с БД
                    print(a)                                                                                            #Вывод запрошеных данных
                if (d == 'closed') or (d == 'Closed'):                                                                  #Обработка выбора пользователя для закрытого голосования
                    a = self.DBA.GetPrivateVotesList()                                                                  #Запрос данных с БД
                    print(a)                                                                                            #Вывод запрошеных данных
            else:
                print('Insufficiently rights access')                                                                   #Оповещение об ошибке при недостатке прав доступа
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя

    def do_InspectionVotes(self, args):
        '''
        Проверка голосов (ИК и аудиторs)
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            if (self.AuthKeyMeth.account['Role'] == "Auditor"):                                                         #Проверка допустимых прав для пользователя
                print()

            else:
                print('Insufficiently rights access')                                                                   #Оповещение об ошибке при недостатке прав доступа
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя

    def do_EditingProfile(self, args):
        '''
        Команда для редактирования профиля
        :param args:
        :return:
        '''
        Transact = {}
        datadict = {}
        datadict['FIO'] = input('Please enter new name \n')                                                             #Информация для изменения данных в профиле
        Transact['data'] = datadict                                                                                     #Сбор данных в транзакцию
        Transact['Type'] = 9                                                                                            #Задача типа транзакции (Редактирование пользователя)
        PrivateKey = self.AuthKeyMeth.account.get['PrivateKey']
        Transact['publicKey'] = self.AuthKeyMeth.account['PublicKey']
        string = json.dumps(Transact, sort_keys=True)
        signature = self.AuthKeyMeth.CreateSignature(string, PrivateKey)
        Transact['signature'] = signature                                                                               #Отправка подписи

    def do_TaxInquiryRecoveryKeys(self, args):
        '''
        Команда подачи запроса для восстановления ключей доступа к системе
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            Transact = {}
            datadict = {}
            datadict['FIO'] = input('Please, enter your name: \n')                                                      #Ввод данных для отправки заявки на восстановление ключа
            Transact['data'] = datadict                                                                                 #Сбор данных в транзакцию
            PrivateKey = self.AuthKeyMeth.account.get['PrivateKey']
            Transact['publicKey'] = self.AuthKeyMeth.account['PublicKey']
            string = json.dumps(Transact, sort_keys=True)
            signature = self.AuthKeyMeth.CreateSignature(string, PrivateKey)
            Transact['signature'] = signature                                                                           #Отправка подписи

    def do_RecoveryKeys(self, args):
        '''
        Команда для восстановления ключей для доступа к системе (только для ЦУУ)
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            if (self.AuthKeyMeth.account['Role'] == "Admin"):                                                           #Проверка допустимых прав для пользователя
                print()

            else:
                print('Insufficiently rights access')                                                                   #Оповещение об ошибке при недостатке прав доступа
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя


    def do_FindUser(self, args):
        '''
        Команда для поиска пользователя в цепочке блоков (для проверки анонимности) только аудиторы
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            if (self.AuthKeyMeth.account['Role'] == "Auditor"):                                                         #Проверка допустимых прав для пользователя
                print()
                search = input('Enter IDUser:\n')
                info = self.DBA.GetPrivateVoteByID(search)                                                              #Запрос к БД для поиска пользователя
                print(info)
            else:
                print('Insufficiently rights access')                                                                   #Оповещение об ошибке при недостатке прав доступа
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя

    def do_AppointAuditor(self, args):
        '''
        Команда для назначения случайного аудитора (только ЦУУ)
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            if (self.AuthKeyMeth.account['Role'] == "Admin"):                                                           #Проверка допустимых прав для пользователя
                print()

            else:
                print('Insufficiently rights access')                                                                   #Оповещение об ошибке при недостатке прав доступа
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя

    def do_AppointUserIK(self, args):
        '''
        Команда для назначения случайного члена избирательной комиссии (только ЦУУ)
        :param args:
        :return:
        '''
        if (self.isAuthorized):                                                                                         #Проверка авторизированного пользователя
            if (self.AuthKeyMeth.account['Role'] == "Admin"):                                                           #Проверка допустимых прав для пользователя
                print()

            else:
                print('Insufficiently rights access')                                                                   #Оповещение об ошибке при недостатке прав доступа
        else:
            print('Please, authorized')                                                                                 #Оповещение об ошибке при запросе неавторизированного пользователя

    def do_exit(self, line):
        '''
        Команда выхода из системы
        :return:
        '''
        exit(0)

if __name__ == '__main__':
    cli = Cli()
    try:
       cli.cmdloop()
    except KeyboardInterrupt:
        print('Fatal Error')                                                                                            #При неудачном запуске консоли, сообщение об ошибке
